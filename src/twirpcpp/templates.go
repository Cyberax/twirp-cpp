package twirpcpp

const cppClientHeaderTpl = `// Code generated by protoc-gen-twirpcpp. DO NOT EDIT.
// source: {{ .InputPath }}
// Functionality: client Twirp stubs
#pragma once

#include "{{.FileName}}.pb.h"
#include <twirp/rpc-defs.h>

{{$nsp := .Namespace -}}

namespace {{$nsp}} {
{{- range $srv := .Services }}
{{""}}
{{""}}{{MakeComment $srv.SourceCodeInfo.LeadingDetachedComments 0 -}}
{{""}}{{MakeComment $srv.SourceCodeInfo.LeadingComments 0 -}}
{{""}}class {{$srv.Name}}ClientInterface {
{{""}}public:
{{""}}    virtual ~{{$srv.Name}}ClientInterface() = default;
{{ range $meth := $srv.Methods }}
{{""}}{{- MakeComment $meth.SourceCodeInfo.LeadingDetachedComments 4 -}}
{{""}}{{- MakeComment $meth.SourceCodeInfo.LeadingComments 4 -}}
{{""}}    virtual absl::StatusOr<{{CppName $meth.Output}}*> {{$meth.Name}}(
{{""}}        google::protobuf::Arena *arena, void *context,
{{""}}        const {{CppName $meth.Input}} *req) = 0; {{ MakeComment $meth.SourceCodeInfo.TrailingComments 1 -}}
{{ end }}
{{""}}};

class {{$srv.Name}}Client : public {{$srv.Name}}ClientInterface {
    std::shared_ptr<trpc::Requester> requester_;
    bool json_;
public:
    {{$srv.Name}}Client(std::shared_ptr<trpc::Requester> requester, bool json) :
        requester_(std::move(requester)), json_(json) {}
{{ range $meth := $srv.Methods }}
{{""}}{{MakeComment $meth.SourceCodeInfo.LeadingDetachedComments 4 -}}
{{""}}{{MakeComment $meth.SourceCodeInfo.LeadingComments 4 -}}
{{""}}    absl::StatusOr<{{CppName $meth.Output}}*> {{$meth.Name}}(
{{""}}        google::protobuf::Arena *arena, void *context,
{{""}}        const {{CppName $meth.Input}} *req) override ; {{ MakeComment $meth.SourceCodeInfo.TrailingComments 1 -}}
{{ end }}
{{""}}};
{{ end -}}
{{""}}
} // namespace {{$nsp}}
`

const cppClientSrcTpl = `// Code generated by protoc-gen-twirpcpp. DO NOT EDIT.
// source: {{ .InputPath }}
// Functionality: implement client Twirp stubs
#include <google/protobuf/util/json_util.h>
#include "{{.FileName}}_client.hpp"

namespace gp = google::protobuf;
{{""}}
{{- $nsp := .Namespace -}}
{{- range $srv := .Services }}
{{- range $meth := $srv.Methods }}
absl::StatusOr<{{CppName $meth.Output}}*> {{CppName $srv}}Client::{{$meth.Name}}(
    gp::Arena *arena, void *context,
    const {{CppName $meth.Input}} *req) {

    absl::StatusOr<std::string> msg = trpc::SerializeMessage(req, json_);
    if (!msg.ok()) {
        return msg.status();
    }

    // Invoke the remote side!
    absl::StatusOr<std::string> result = requester_->MakeRequest(arena, context, msg.value(), json_,
        "{{$srv.Package.ProtoName}}.{{$srv.Name}}", "{{$meth.Name}}");
    if (!result.ok()) {
        return result.status();
    }

    absl::StatusOr<trpc::OwnedPtr<{{CppName $meth.Output}}>> res =
        trpc::DeserializeMessage<{{CppName $meth.Output}}>(arena, result.value(), json_);
    if (!res.ok()) {
        return res.status();
    }

    return res.value().release();
}
{{ end -}}
{{ end -}}
`

const cppServerHeaderTpl = `// Code generated by protoc-gen-twirpcpp. DO NOT EDIT.
// source: {{ .InputPath }}
// Functionality: server Twirp stubs
#pragma once

#include "{{.FileName}}.pb.h"
#include <twirp/rpc-defs.h>

{{$nsp := .Namespace -}}

namespace {{$nsp}} {

namespace gp = google::protobuf;

{{- range $srv := .Services }}
{{""}}
{{""}}{{MakeComment $srv.SourceCodeInfo.LeadingDetachedComments 0 -}}
{{""}}{{MakeComment $srv.SourceCodeInfo.LeadingComments 0 -}}
{{""}}class {{$srv.Name}}Service {
{{""}}public:
{{""}}    virtual ~{{$srv.Name}}Service() = default;
{{ range $meth := $srv.Methods }}
{{""}}{{MakeComment $meth.SourceCodeInfo.LeadingDetachedComments 4 -}}
{{""}}{{MakeComment $meth.SourceCodeInfo.LeadingComments 4 -}}
{{""}}    virtual absl::StatusOr<{{CppName $meth.Output}}*> {{$meth.Name}}(
{{""}}        gp::Arena *arena, trpc::RequestContext *context,
{{""}}        const {{CppName $meth.Input}} *req) = 0; {{ MakeComment $meth.SourceCodeInfo.TrailingComments 1 }}
{{ end -}}
{{""}}};

{{""}}class {{$srv.Name}}ServiceHost : public trpc::ServiceHostBase {
{{""}}    std::shared_ptr<{{$srv.Name}}Service> handler_;
{{""}}    std::set<std::string_view> methods_;
{{""}}public:
{{""}}    explicit {{$srv.Name}}ServiceHost(std::shared_ptr<{{$srv.Name}}Service> handler) :
{{""}}        handler_(std::move(handler)) {
{{""}}        methods_ = {
{{ range $meth := $srv.Methods -}}
{{""}}            "{{$meth.Name}}",
{{ end -}}
{{""}}        };
{{""}}    }
{{""}}
{{""}}    std::string_view GetServiceName() const override {
{{""}}        return "{{$srv.Package.ProtoName}}.{{$srv.Name}}";
{{""}}    }
{{""}}
{{""}}    const std::set<std::string_view>& GetMethods() const override {
{{""}}        return methods_;
{{""}}    }
{{""}}
{{""}}    trpc::StatusOrPtr<gp::Message> Invoke(gp::Arena *arena,
{{""}}        const std::string_view &method, const std::span<const char> &argument1, bool json,
{{""}}        trpc::RequestContext *context) override;
{{""}}};
{{ end -}}
{{""}}
} // namespace {{$nsp}}
`

const cppServerSrcTpl = `// Code generated by protoc-gen-twirpcpp. DO NOT EDIT.
// source: {{ .InputPath }}
// Functionality: implement server Twirp stubs
#include "{{.FileName}}_server.hpp"

namespace gp = google::protobuf;
{{""}}
{{- $nsp := .Namespace -}}
{{- range $srv := .Services }}
trpc::StatusOrPtr<gp::Message> {{CppName $srv}}ServiceHost::Invoke(gp::Arena *arena,
    const std::string_view &method, const std::span<const char> &argument1, bool json,
    trpc::RequestContext *context) {

    if (argument1.size() >= INT_MAX) {
        return absl::OutOfRangeError("Serialized object's size is out of range");
    }
{{ range $meth := $srv.Methods }}
    if (method == "{{$meth.Name}}") {
        absl::StatusOr<trpc::OwnedPtr<{{CppName $meth.Input}}>> reqObj =
            trpc::DeserializeMessage<{{CppName $meth.Input}}>(arena, argument1, json);
        if (!reqObj.ok()) {
            return reqObj.status();
        }

        absl::StatusOr<{{CppName $meth.Output}}*> res = handler_->{{$meth.Name}}(
            arena, context, reqObj.value().get());
        if (!res.ok()) {
            return res.status();
        }

        return trpc::StatusOrPtr<gp::Message>(res.value());
    }
{{ end }}
    // We should never reach here normally
    return absl::InternalError("incorrect method invoked");
}
{{ end -}}
`
